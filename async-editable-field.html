<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../paper-spinner/paper-spinner.html">
<link rel="import" href="../promise-polyfill/promise-polyfill-lite.html">
<link rel="import" href="../iron-ajax/iron-ajax.html">

<dom-module id="async-editable-field">
  <template>
    <style>
      #errorMark, #validMark {
        font-size: 15px;
        margin-right: -15px;
        font-weight: bold;
        position: relative;
        left: -25px;
        top: 2px;
      }
      #errorMark {
        color: red;
      }
      #warning {
        color: red;
        padding-top: 5px;
      }
      #validMark {
        color: #99CA3C;
      }
      #displayValue {
        min-width: 100px;
        display: inline-block;
      }
      #textInput {
        padding: 4px;
        border-radius: 3px;
        border: solid 1px #4DC1E8;
      }
      #loading {
        position: absolute;
        padding-left: 10px;
      }
      button {
        background-color: var(--button-color, #99CA3C);
        color: var(--button-text-color, #fff);
        border: none;
        min-width: 69px;
        height: 24px;
      }
      button:disabled {
        background-color: var(--disabled-button-color, #C2E08A);
      }
      #displayValue, #textInput, #warning, button {
        font-family: Arial, Helvetica, sans-serif;
        font-size: 12px;
      }
    </style>

    <iron-ajax id="ajaxRequest" url$="{{url}}" method="post" content-type="application/json" body$="{{requestBody}}" handle-as="json"
      on-response="_handleResponse" on-error="_handleErrorResponse"></iron-ajax>
    <span id="displayValue" style$="display:{{_getValueDisplayStyle(editing)}}" on-tap="_handleFieldClick">{{value}}</span>
    <input id="textInput" hidden$="{{!editing}}" value="{{inputValue::input}}" placeholder$="{{value}}" on-keyup="_handleKeyUp"
       on-blur="_handleBlur" />
    <span id="errorMark" hidden$="{{!error}}">&#10006;</span>
    <span id="validMark" hidden$="{{!_shouldShowValidMark(editing, error, inputValue)}}">&#10003;</span>
    <span id="loading" hidden$="{{!loading}}">
      <paper-spinner active></paper-spinner>
    </span>
    <button id="saveButton" hidden$="{{_shouldHideButtons(editing, loading, hideSaveButton)}}" disabled$="{{_shouldDisableSaveButton(inputValue, error)}}" on-tap="save">{{saveText}}</button>
    <button id="cancelButton" hidden$="{{_shouldHideButtons(editing, loading, hideCancelButton)}}" on-tap="cancelEdit">{{cancelText}}</button>
    <div id="warning" hidden$="{{_shouldHideWarning(editing, error, warningText)}}">{{warningText}}</div>
  </template>

  <script>
    /**
     * `async-editable-field`
     * This is an editable field component which can validate input and POST asynchronously
     *
     * @customElement
     * @polymer
     * @demo demo/index.html
     */
     Polymer({
      
      is: 'async-editable-field',

      properties: {
        value: {
          type: String,
          value: ''
        },
        name: {
          type: String,
          value: 'value'
        },
        saveText: {
          type: String,
          value: 'OK'
        },
        cancelText: {
          type: String,
          value: 'Cancel'
        },
        url: {
          type: String,
          value: null
        },
        warningText: {
          type: String,
          value: null
        },
        hideSaveButton: {
          type: Boolean,
          value: false
        },
        hideCancelButton: {
          type: Boolean,
          value: false
        },
        disableClickToEdit: {
          type: Boolean,
          value: false
        },
        readonly: {
          type: Boolean,
          value: false
        },
        saveOnBlur: {
          type: Boolean,
          value: false
        },
        validateWhileTyping: {
          type: Boolean,
          value: false
        },
        inputValue: {
          type: String,
          value: ""
        },
        requestBody: {
          type: String,
          value: "{}",
          readOnly: true
        },
        editing: {
          type: Boolean,
          value: false,
          readOnly: true
        },
        loading: {
          type: Boolean,
          value: false,
          readOnly: true
        },
        error: {
          type: Boolean,
          value: false,
          readOnly: true
        },
        validationFunction: {
          type: Function,
          value: null,
          readOnly: true
        },
        successResponseCallback: {
          type: Function,
          value: null,
          readOnly: true
        },
        errorResponseCallback: {
          type: Function,
          value: null,
          readOnly: true
        }
      },

      setSuccessResponseCallback: function(func) { this._setSuccessResponseCallback(func); },
      setErrorResponseCallback: function(func) { this._setErrorResponseCallback(func); },
      setValidationFunction: function(func) { this._setValidationFunction(func); },

      validate: function() {
        if (this.readonly)
          return false;

        if (!this.validationFunction)
          return true;

        if (this.validationFunction(this.inputValue)) {
          this._setError(false);
          return true;
        } else {
          this._setError(true);
          return false;
        }
      },

      save: function() {
        if (!this.validate())
            return;

        if (this.inputValue == this.value || !this.url) {
          this._saveEdit();
          return;
        }

        this._setError(false);
        this._setLoading(true);
        this._setRequestBody('{ "' + this.name + '": "' + this.inputValue + '" }');
        this.$.ajaxRequest.generateRequest();
      },

      editValue: function() {
        if (this.readonly)
          return;

        this._setEditing(true);
        this.inputValue = "";
      },

      cancelEdit: function() {
        this.inputValue = this.value;
        this._finishEdit();
      },

      _saveEdit() {
        this.value = this.inputValue;
        this._finishEdit();
      },

      _finishEdit: function() {
        this._setLoading(false);
        this._setEditing(false);
        this._setError(false);
      },

      _handleResponse: function(e) {
        this._saveEdit();

        if (this.successResponseCallback)
          this.successResponseCallback(e.detail.response);
      },

      _handleErrorResponse: function(e) {
        this._setLoading(false);
        this._setError(true);
        
        if (this.errorResponseCallback)
          this.errorResponseCallback(e.detail.request.xhr.response, e.detail.request.status);
      },

      _handleKeyUp: function(e) {
        if (e.keyCode === 13 && this.inputValue) // enter/return key
          this.save();
        else if (e.keyCode === 27) // escape key
          this.cancelEdit();
        else {
          this._setError(false);
          if (this.validateWhileTyping)
            this.validate();
        }
      },

      _shouldShowValidMark: function(editing, error, inputValue) {
        return editing && !error && inputValue;
      },

      _handleFieldClick: function() {
        if (!this.disableClickToEdit)
          this.editValue();
      },

      _handleBlur: function() {
        if (!this.saveOnBlur)
          return;

        if (!this.inputValue || this.inputValue == this.value)
          this.cancelEdit();
        else
          this.save();
      },

      _shouldHideButtons: function(editing, loading, hideButton) {
        return !editing || loading || hideButton;
      },

      _shouldDisableSaveButton: function(inputValue, error) {
        return !inputValue || error;
      },

      _shouldHideWarning: function(editing, error, warningText) {
        return !editing || !error || !warningText;
      },

      _getValueDisplayStyle(editing) {
        return editing ? "none" : "inline-block";
      }
      
    });
  </script>
</dom-module>